"use strict";(self.webpackChunkgetx_document=self.webpackChunkgetx_document||[]).push([[259],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>y});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(n),h=o,y=d["".concat(l,".").concat(h)]||d[h]||p[h]||r;return n?a.createElement(y,i(i({ref:t},c),{},{components:n})):a.createElement(y,i({ref:t},c))}));function y(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2518:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));const r={title:"Why GetX?",description:"Why GetX?",hide_table_of_contents:!1},i="Why Getx?",s={type:"mdx",permalink:"/getx-docs/why-getx",source:"@site/src/pages/why-getx.md",title:"Why GetX?",description:"Why GetX?",frontMatter:{title:"Why GetX?",description:"Why GetX?",hide_table_of_contents:!1}},l=[],u={toc:l},c="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"why-getx"},"Why Getx?"),(0,o.kt)("p",null,"1- Many times after a Flutter update, many of your packages will break. Sometimes compilation errors happen, errors\noften appear that there are still no answers about, and the developer needs to know where the error came from, track the\nerror, only then try to open an issue in the corresponding repository, and see its problem solved. Get centralizes the\nmain resources for development (State, dependency and route management), allowing you to add a single package to your\npubspec, and start working. After a Flutter update, the only thing you need to do is update the Get dependency, and get\nto work. Get also resolves compatibility issues. How many times a version of a package is not compatible with the\nversion of another, because one uses a dependency in one version, and the other in another version? This is also not a\nconcern using Get, as everything is in the same package and is fully compatible."),(0,o.kt)("p",null,"2- Flutter is easy, Flutter is incredible, but Flutter still has some boilerplate that may be unwanted for most\ndevelopers, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"Navigator.of(context).push (context, builder [...]"),". Get simplifies development. Instead of writing\n8 lines of code to just call a route, you can just do it: ",(0,o.kt)("inlineCode",{parentName:"p"},"Get.to(Home())")," and you're done, you'll go to the next page.\nDynamic web urls are a really painful thing to do with Flutter currently, and that with GetX is stupidly simple.\nManaging states in Flutter, and managing dependencies is also something that generates a lot of discussion, as there are\nhundreds of patterns in the pub. But there is nothing as easy as adding a \".obs\" at the end of your variable, and place\nyour widget inside an Obx, and that's it, all updates to that variable will be automatically updated on the screen."),(0,o.kt)("p",null,"3- Ease without worrying about performance. Flutter's performance is already amazing, but imagine that you use a state\nmanager, and a locator to distribute your blocs/stores/controllers/ etc. classes. You will have to manually call the\nexclusion of that dependency when you don't need it. But have you ever thought of simply using your controller, and when\nit was no longer being used by anyone, it would simply be deleted from memory? That's what GetX does. With\nSmartManagement, everything that is not being used is deleted from memory, and you shouldn't have to worry about\nanything but programming. You will be assured that you are consuming the minimum necessary resources, without even\nhaving created a logic for this."),(0,o.kt)("p",null,"4- Actual decoupling. You may have heard the concept \"separate the view from the business logic\". This is not a\npeculiarity of BLoC, MVC, MVVM, and any other standard on the market has this concept. However, this concept can often\nbe mitigated in Flutter due to the use of context.\nIf you need context to find an InheritedWidget, you need it in the view, or pass the context by parameter. I\nparticularly find this solution very ugly, and to work in teams we will always have a dependence on View's business\nlogic. Getx is unorthodox with the standard approach, and while it does not completely ban the use of StatefulWidgets,\nInitState, etc., it always has a similar approach that can be cleaner. Controllers have life cycles, and when you need\nto make an APIREST request for example, you don't depend on anything in the view. You can use onInit to initiate the\nhttp call, and when the data arrives, the variables will be populated. As GetX is fully reactive (really, and works\nunder streams), once the items are filled, all widgets that use that variable will be automatically updated in the view.\nThis allows people with UI expertise to work only with widgets, and not have to send anything to business logic other\nthan user events (like clicking a button), while people working with business logic will be free to create and test the\nbusiness logic separately."))}d.isMDXComponent=!0}}]);